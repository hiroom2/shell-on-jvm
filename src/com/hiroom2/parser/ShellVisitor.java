/**
 * @file ShellVisitor.java
 * @author Hiroo MATSUMOTO <hiroom2.mail@gmail.com>
 */
package com.hiroom2.parser;

import com.hiroom2.cmd.ShellCmd;
import com.hiroom2.cmd.ShellCmds;
import com.hiroom2.gen.ASTBinOp;
import com.hiroom2.gen.ASTBinOpAdd;
import com.hiroom2.gen.ASTBinOpAssign;
import com.hiroom2.gen.ASTBinOpMul;
import com.hiroom2.gen.ASTBlock;
import com.hiroom2.gen.ASTBreakStmt;
import com.hiroom2.gen.ASTCall;
import com.hiroom2.gen.ASTComp;
import com.hiroom2.gen.ASTCond;
import com.hiroom2.gen.ASTExpr;
import com.hiroom2.gen.ASTFunc;
import com.hiroom2.gen.ASTIdentifier;
import com.hiroom2.gen.ASTIfStmt;
import com.hiroom2.gen.ASTInteger;
import com.hiroom2.gen.ASTRefArg;
import com.hiroom2.gen.ASTRefRet;
import com.hiroom2.gen.ASTRefVar;
import com.hiroom2.gen.ASTReturnStmt;
import com.hiroom2.gen.ASTStart;
import com.hiroom2.gen.ASTStmt;
import com.hiroom2.gen.ASTStmts;
import com.hiroom2.gen.ASTString;
import com.hiroom2.gen.ASTValue;
import com.hiroom2.gen.ASTWhileStmt;
import com.hiroom2.gen.ParserVisitor;
import com.hiroom2.gen.SimpleNode;

/**
 * Class of visitor which extends class generated by JavaCC.
 */
public class ShellVisitor implements ParserVisitor {
  
  /** Function declarations like func() {} */
  private final ShellFuncs mFuncs;
  /** Variable declarations like v=0 */
  private final ShellVars mVars;
  /** Arguments like 'func arg1 arg2' and '$1 $2' */
  private final ShellArgs mArgs;
  /** Return value like $? */
  private final ShellValue mRet;
  /** Flag which break statement or return statement is done */
  private boolean mBreak;
  /** Built-in commands */
  private final ShellCmds mCmds;
  
  public ShellVisitor() {
    mFuncs = new ShellFuncs();
    mVars = new ShellVars();
    mArgs = new ShellArgs();
    mRet = new ShellValue("0", ShellValue.TYPE_INTEGER);
    mBreak = false;
    mCmds = new ShellCmds();
  }
  
  @Override
  public Object visit(SimpleNode node, Object data) {
    return null;
  }
  
  @Override
  public Object visit(ASTStart node, Object data) {
    int size = node.jjtGetNumChildren();
    for (int i = 0; i < size; ++i)
      node.jjtGetChild(i).jjtAccept(this, null);
    return null;
  }
  
  @Override
  public Object visit(ASTStmts node, Object data) {
    int size = node.jjtGetNumChildren();
    for (int i = 0; i < size; ++i)
      node.jjtGetChild(i).jjtAccept(this, null);
    return null;
  }
  
  @Override
  public Object visit(ASTFunc node, Object data) {
    /** Get name of function declaration. */
    String name = node.image;
    /** Keep ASTBlock which points function body. */
    ASTBlock block = (ASTBlock) node.jjtGetChild(0);
    mFuncs.set(new ShellFunc(name, block));
    return null;
  }
  
  @Override
  public Object visit(ASTStmt node, Object data) {
    /** mBreak will be set by ASTWhileStmt visitor which has some ASTStmt */
    int size = node.jjtGetNumChildren();
    for (int i = 0; i < size; ++i)
      if (!mBreak)
        node.jjtGetChild(i).jjtAccept(this, null);
    return null;
  }
  
  @Override
  public Object visit(ASTBlock node, Object data) {
    int size = node.jjtGetNumChildren();
    for (int i = 0; i < size; ++i)
      node.jjtGetChild(i).jjtAccept(this, null);
    return null;
  }
  
  @Override
  public Object visit(ASTIfStmt node, Object data) {
    /**
     * First child points if condition, second points if body, third points elif
     * condition, fourth points elif body, and the last child points else body.
     */
    int i, size = node.jjtGetNumChildren();
    for (i = 0; i < size - 1; i += 2) {
      ShellValue value = (ShellValue) node.jjtGetChild(i).jjtAccept(this, data);
      String getValue = value.getValue();
      /** Check condition is 1 */
      if (getValue.equals("1")) {
        node.jjtGetChild(i + 1).jjtAccept(this, null);
        return null;
      }
    }
    
    /** Check which else condition is exists. */
    if (i >= size - 1 && size % 2 != 0)
      node.jjtGetChild(size - 1).jjtAccept(this, null);
    return null;
  }
  
  @Override
  public Object visit(ASTExpr node, Object data) {
    int size = node.jjtGetNumChildren();
    for (int i = 0; i < size; ++i)
      node.jjtGetChild(i).jjtAccept(this, null);
    return null;
  }
  
  @Override
  public Object visit(ASTBinOp node, Object data) {
    int size = node.jjtGetNumChildren();
    for (int i = 0; i < size; ++i)
      node.jjtGetChild(i).jjtAccept(this, null);
    return null;
  }
  
  @Override
  public Object visit(ASTBinOpAssign node, Object data) {
    /** Treat left tree as identifier and right tree as value around '='. */
    String id = (String) node.jjtGetChild(0).jjtAccept(this, data);
    /** Evaluate left tree which may ASTBinOpAdd. */
    ShellValue value = (ShellValue) node.jjtGetChild(1).jjtAccept(this, data);
    mVars.set(id, value);
    return null;
  }
  
  @Override
  public Object visit(ASTBinOpAdd node, Object data) {
    /** Treat left tree and right tree as ASTBinOpMul around '+' or '-'. */
    int size = node.jjtGetNumChildren();
    ShellValue left = (ShellValue) node.jjtGetChild(0).jjtAccept(this, data);
    /** Right tree may have multiple ASTBinOpMul like 1 + 2 * 3 + 4. */
    for (int i = 1; i < size; ++i) {
      ShellValue right = (ShellValue) node.jjtGetChild(i).jjtAccept(this, data);
      if (node.image.equals("+"))
        left.add(right);
      else
        left.sub(right);
    }
    return left;
  }
  
  @Override
  public Object visit(ASTBinOpMul node, Object data) {
    /** Treat left tree and right tree as ASTValue around '*' or '/'. */
    int size = node.jjtGetNumChildren();
    /** Right tree may have multiple ASTValue like 1 * 2 * 3. */
    ShellValue left = (ShellValue) node.jjtGetChild(0).jjtAccept(this, data);
    for (int i = 1; i < size; ++i) {
      ShellValue right = (ShellValue) node.jjtGetChild(i).jjtAccept(this, data);
      if (node.image.equals("*"))
        left.mul(right);
      else
        left.div(right);
    }
    return left;
  }
  
  @Override
  public Object visit(ASTValue node, Object data) {
    /** Return ShellValue which will be used. */
    return node.jjtGetChild(0).jjtAccept(this, null);
  }
  
  @Override
  public Object visit(ASTInteger node, Object data) {
    /** Return ShellValue which has integer. */
    return new ShellValue(node.image, ShellValue.TYPE_INTEGER);
  }
  
  @Override
  public Object visit(ASTRefVar node, Object data) {
    /** Return ShellValue which identifier has. */
    ShellVar id = mVars.get(node.image);
    if (id == null)
      return new ShellValue("0", ShellValue.TYPE_INTEGER);
    return new ShellValue(id.getValue());
  }
  
  @Override
  public Object visit(ASTIdentifier node, Object data) {
    return node.image;
  }
  
  @Override
  public Object visit(ASTString node, Object data) {
    /** Return ShellValue which has string. */
    return new ShellValue(node.image, ShellValue.TYPE_STRING);
  }
  
  @Override
  public Object visit(ASTCall node, Object data) {
    String name = node.image;
    ShellFunc func = mFuncs.get(name);
    /** If func is not null, there is function declaration. */
    if (func != null) {
      /** Set call argument. */
      int size = node.jjtGetNumChildren();
      for (int i = 0; i < size; ++i)
        mArgs.push((ShellValue) node.jjtGetChild(i).jjtAccept(this, data));
      /**
       * Visit body of function declaration. If body has return statement,
       * ASTReturnStmt will set mRet.
       */
      visit(func.getBlock(), data);
      mArgs.clear();
      mBreak = false;
      return null;
    }
    
    int size = node.jjtGetNumChildren();
    ShellCmd cmd = mCmds.get(name, size);
    if (cmd == null)
      return null;
    
    /** Set call argument. */
    ShellValue[] args = new ShellValue[size];
    for (int i = 0; i < size; ++i)
      args[i] = (ShellValue) node.jjtGetChild(i).jjtAccept(this, data);
    
    /** Run built-in commands and set return value. */
    mRet.setValue("" + cmd.run(args));
    return null;
  }
  
  @Override
  public Object visit(ASTRefArg node, Object data) {
    /** Return ShellValue in argument like $1. */
    int idx = Integer.valueOf(node.image) - 1;
    return new ShellValue(mArgs.get(idx));
  }
  
  @Override
  public Object visit(ASTWhileStmt node, Object data) {
    while (!mBreak) {
      ShellValue cond = (ShellValue) node.jjtGetChild(0).jjtAccept(this, data);
      /** Check while condition. */
      if (cond.getValue().equals("0"))
        break;
      /** Run while body. If while body has break statement, mBreak will be set. */
      node.jjtGetChild(1).jjtAccept(this, data);
    }
    mBreak = false;
    return null;
  }
  
  @Override
  public Object visit(ASTCond node, Object data) {
    /** This node may be ASTComp. */
    return node.jjtGetChild(0).jjtAccept(this, data);
  }
  
  @Override
  public Object visit(ASTComp node, Object data) {
    /**
     * Treat left tree and right tree as ASTBinOpAdd around '>=', '>', ... or
     * '!='.
     */
    String comp = node.image;
    ShellValue lv = (ShellValue) node.jjtGetChild(0).jjtAccept(this, data);
    ShellValue rv = (ShellValue) node.jjtGetChild(1).jjtAccept(this, data);
    if (comp.equals(">="))
      return ShellValue.GE(lv, rv);
    else if (comp.equals(">"))
      return ShellValue.GT(lv, rv);
    else if (comp.equals("<="))
      return ShellValue.LE(lv, rv);
    else if (comp.equals("<"))
      return ShellValue.LT(lv, rv);
    else if (comp.equals("=="))
      return ShellValue.EQ(lv, rv);
    else if (comp.equals("!="))
      return ShellValue.NE(lv, rv);
    return null;
  }
  
  @Override
  public Object visit(ASTBreakStmt node, Object data) {
    mBreak = true;
    return null;
  }
  
  @Override
  public Object visit(ASTReturnStmt node, Object data) {
    /** If size > 0, return statement has value like return $value. */
    int size = node.jjtGetNumChildren();
    if (size > 0)
      mRet.setValue(((ShellValue) node.jjtGetChild(0).jjtAccept(this, data))
          .getValue());
    else
      mRet.setValue("0");
    mBreak = true;
    return null;
  }
  
  @Override
  public Object visit(ASTRefRet node, Object data) {
    /** Return $? copied value. */
    return new ShellValue(mRet);
  }
}
